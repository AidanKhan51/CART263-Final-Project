/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/drawer-one.glb 
*/

//Imports
import React, { useEffect, useState } from "react";
import { useGraph } from '@react-three/fiber'
import { useGLTF, Html, useAnimations, Float } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import Folder from "./Folder";

{/*
  IMPORTANT: Drawer-one, Drawer-two, Drawer-three, Drawer-four and Folder are pretty much identical. 
  The identical code will be covered here, in Drawer One, leaving the others mostly uncommented as they all function very similarly.
  The only one with a significant difference is Folder.jsx
  */ }

{/*store model as variable to export to experience*/ }
const DrawerOne = (props) => {
  {/*Generated by gltfjsx skinner*/ }
  const group = React.useRef()
  const { scene, animations } = useGLTF('./models/drawer-one.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  {/*Animations*/ }
  const { actions, names, mixer } = useAnimations(animations, group)
  {/*Initializes idle animation*/ }
  const [initializeLoop, setInitializeLoop] = React.useState(true);
  {/*Variable that determines if the drawer is open*/ }
  const [drawerIsOpen, setDrawerIsOpen] = React.useState(false);
  {/*determines if folder is rendered based on if drawer is open*/ }
  const [renderFolder, setRenderFolder] = React.useState(false);
  {/*Displays title of drawer onto the monitor*/ }
  const [drawerTitle, setDrawerTitle] = React.useState(false);

  {/*Animation sequence. The logic behind it is that all animations essentially follow a "flow chart" where there's only one animation that can possibly play after the other.
    Therefore, this detects if a certain animation is playing, and then if it changes, it plays the next animation in the flow chart*/ }
  useEffect(() => {
    const fn = (e) => {
      switch (e.action) {
        case actions[names[1]]:
          mixer.stopAllAction();
          actions[names[5]].reset().play();
          {/*renders folder AFTER animation finishes*/ }
          setRenderFolder(true)
          break;
        case actions[names[2]]:
          mixer.stopAllAction();
          actions[names[4]].reset().play();
          break;
        case actions[names[0]]:
          mixer.stopAllAction();
          actions[names[3]].reset().play();
          break;
        case actions[names[6]]:
          mixer.stopAllAction();
          {/*Sets drawer to closed AFTER animation finishes*/ }
          setDrawerIsOpen(false)
          actions[names[3]].reset().play();
          break;
      }
    }
    mixer.addEventListener('finished', fn)
    return () => {
      mixer.removeEventListener('finished', fn)
    }
  }, [mixer, names]);

  {/*Loop that plays when program starts to set all models to idle position. Breaks in onPointerLeave*/ }
  useEffect(() => {
    if (initializeLoop === true) {
      actions[names[3]].reset().play();
    } else { }
  })

  return <>
    {/*Renders drawer title that floats when drawer is hovered over*/}
    <Float floatIntensity={3} rotationIntensity={0} speed={3}>
      {drawerTitle && <Html className="drawer_title" position={[8, 76, 2]} rotation={[-3.1415927, 1.4835301, -3.1415927]} transform occlude>
        Images
      </Html>}
    </Float>
    <group
      {...props}
      dispose={null}
      so onClick={(e) => {
        {/*switch for when drawer is either opened or closed*/ }
        switch (drawerIsOpen) {
          case false:
            {/*If drawer is not already open, then open it*/ }
            {/*stops raycast from propogating through and interacting with other objects*/ }
            e.stopPropagation()
            {/*play animation*/ }
            actions[names[1]].repetitions = 1;
            mixer.stopAllAction();
            actions[names[1]].reset().play();
            {/*Positions and angles camera to drawer*/ }
            props.onCameraPositionChange([48, 48, 0])
            props.onCameraAngleChange([0, 20, 0])
            {/*locks camera movement*/ }
            props.setEnabled(false)
            {/*sets drawer as open*/ }
            setDrawerIsOpen(true)
            break;
          case true:
            {/*Stops raycast from interacting with other objects*/ }
            e.stopPropagation()
            {/*do not allow folder to render*/ }
            setRenderFolder(false)
            actions[names[6]].repetitions = 1;
            mixer.stopAllAction();
            {/*Disable drawer title*/ }
            setDrawerTitle(false)
            actions[names[6]].reset().play();
            {/*enable camera*/ }
            props.setEnabled(true)
            break;
        }
      }}
      onPointerEnter={() => {
        {/*when pointer is on an object and the drawer is not open*/ }
        if (drawerIsOpen === false) {
          {/*hover animation*/ }
          actions[names[2]].repetitions = 1;
          mixer.stopAllAction();
          {/*show drawer title*/ }
          setDrawerTitle(true);
          {/*play closed idle animation*/ }
          actions[names[2]].reset().play();
        }
      }}
      onPointerLeave={() => {
        {/*when pointer leaves object and the drawer is not open*/ }
        if (drawerIsOpen === false) {
          {/*play animation to close drawer*/ }
          actions[names[0]].repetitions = 1;
          mixer.stopAllAction();
          {/*Hide drawer title*/ }
          setDrawerTitle(false);
          {/*break initial idle loop*/ }
          setInitializeLoop(false);
          {/*play closed idle animation*/ }
          actions[names[0]].reset().play();
        }
      }}
    >
      {/*3D model data*/}
      <group ref={group} {...props} dispose={null}>
        <group name="Scene">
          <group name="SliderOne" rotation={[0, 0, -Math.PI / 2]} scale={0.571}>
            <primitive object={nodes.BoneBig} />
          </group>
          <mesh name="Cube004" geometry={nodes.Cube004.geometry} material={materials['Slider 1']} position={[0.497, 3.34, 0.828]} scale={[0.861, 0.054, 0.032]} />
        </group>
      </group>
    </group >
    {/*If drawer is open and form has been submitted, render folder*/}
    {renderFolder && props.onFolderSubmitted && <Folder scale={4} file={props.file} title={props.title} description={props.description} />}
  </>;
}
{/*export to Experience.jsx*/ }
export default DrawerOne

useGLTF.preload('./models/drawer-one.glb')
